# Интерпретация и нормализация

Интерпретация — это способ сохранить результат анализа текста в табличной форме, удобной для последующей обработки, например, для сохранения в базу данных. Интерпретация является последним этапом обработки текста в Томита-парсере. Процесс интерпретации состоит в распределении подцепочек из выделенной грамматикой цепочки по полям факта.

Факт — это множество значений полей-атрибутов, связанных смысловыми отношениями. Например, факт «Meeting» может иметь поля «Place» , «Time» и «Theme».


## Более формально <a name="defin"></a>

Интерпретация — это процедура, которая позволяет отобразить древесную синтаксическую структуру во множество линейно организованных фактов. Каждый факт можно представить как таблицу из одной строки и одной или нескольких колонок: в каждой ячейке этой таблицы содержится объект. Цель интерпретации состоит в сопоставлении множества строящихся нетерминалов грамматики множеству выделяемых для определенного типа факта объектов, т.е. в распределении подцепочек слов по заранее заданным полям в таблице.


## Описание типов фактов <a name="facts"></a>

Любой факт, порождаемый грамматикой, должен быть описан. Факты описываются в словаре типа gzt. Название факта задается служебным словом `message`, после имени факта записывается его тип. Базовый тип всех фактов `NFactType.TFact`. Поля фактов перечисляются в фигурных скобках `{ }`.

> ```no-highlight
> message SomeFactName : NFactType.TFact
> {
> ...
> }
> ```

Типы фактов могут наследоваться. При этом все поля, входящие в базовый тип факта, войдут и в производный тип. Для того, чтобы от базового типа факта можно было наследовать производные, нужно указывать диапазон номеров полей, зарезервированных для использования в производных типах: `extensions 2 to 10`.

> ```no-highlight
> message BasicFact : NFactType.TFact
> {
>   required string field1 = 1;
>   extensions 2 to 10;
> }
> message DerivedFact : BasicFact
> {
>   required string field2 = 2;
>   required string field3 = 3;
> }
> ```

Язык описания типов Protobuff описан в документации [Protocol Buffers/Language Guide](https://developers.google.com/protocol-buffers/docs/proto#extensions).


## Поля фактов <a name="poljafaktov"></a>

Все поля фактов имеют следующие характеристики: имя поля, тип поля, обязательность заполнения поля. Явное указание всех трех характеристик обязательно при описании типа факта.

Можно использовать Поля фактов относятся к одному из четырех типов, перечисленных в таблице.

**Тип поля** | **Описание** | **Примеры значений**
----- | ----- | -----
`string` | Строка. Это универсальное поле, может содержать любые строковые значения | расписная черепаха<br/><br/>11.5<br/><br/>news.yandex.ru
`bool` | Булевский тип данных, допускает одно из двух значений: `true` и `false` | `true`<br/><br/>`false`
`NFactType.TFio` | Тип для хранения ФИО: полных фамилии, имени и отчества или инициалов. | Мюррей Билл<br/><br/>Калугина Л.П.
`NFactType.TDate` | Тип для хранения даты и времени или временного интервала, выделенных статьей одного из двух специальных типов: `date` и `date_chain`. | 1997-11-23 00:00:00<br/><br/>2011-06-17 19:30:00<br/><br/>2012-02-20 00:00:00 - 2012-02-22 00:00:00


Обязательность заполнения поля факта задается служебным словом `required` или `optional`, затем следует название типа поля (см. таблицу выше), а затем его название и после знака равенства `=` номер поля факта и точка с запятой. Слова `required` или `optional` означают, что поле факта соответственно обязательное или факультативное. Если в процессе построения дерева у факта остается незаполненным хотя бы одно обязательное поле, то факт не извлекается.

> `optional string CountryName = 1;`

Номера поля должны быть уникальными для каждого факта. Поэтому важно иметь в виду, что если факт унаследовал свой тип от другого факта, то он также унаследовал и его поля с их номерами.


## Значения полей по умолчанию <a name="znachenijapolejjpoumolchaniju"></a>

При описании поля факта ему можно приписать значение по умолчанию. В этом случае если будет заполнено хотя бы одно другое поле этого факта, то в этом поле уже будет заданное по умолчанию значение. Значение по умолчанию изменится, если при интерпретации это поле будет заполнено другой цепочкой.

Значение по умолчанию задается в квадратных скобках `[ ]` после объявления поля, в параметре `default`, как это сделано в следующем примере:

> `optional string Animal = 1 [ default = "неведома зверушка" ];`


## Капитализация полей фактов <a name="kapitalizacijapolejjfaktov"></a>

При описании фактов можно указать желаемую капитализацию их значений при выводе. Пометы, влияющие на капитализацию, пишутся в квадратных скобках `[ ]` после описания полей. Разделителем между пометами служит запятая. Такие пометы и их значения перечислены ниже:

Тип поля | Описание
----- | -----
`[(NFactType.normcase) = TITLE_CASE]` | Капитализировать первую букву первого слова
`[(NFactType.normcase) = CAMEL_CASE]` | Капитализировать первую букву у всех слов



## Сохранение лемм <a name="soxranenielemm"></a>

Помета `[(NFactType.info) = true]` указывает парсеру, что необходимо сохранять в выходной файл леммы слов и помечать главные слова.


## Интерпретация фактов в грамматиках <a name="interpretacijafaktovvgrammatikax"></a>

Для записи цепочки в поле факта интерпретации в Томите используется оператор `interp`. Цепочка, распознанная символом за которым следует `interp`, записывается в поле факта, которое обозначается в скобках после `interp`.

> `Animal -> Cat interp (Animal.Small);`

В этом примере цепочка собранная нетерминалом `Cat` записывается в поле `Small` факта `Animal`. Один символ можно интерпретировать в несколько полей, в том числе и в несколько полей разных фактов. Для этого поля перечисляются через точку с запятой `;`.

> `Animal -> Cat interp (Animal.Small; Object.Animate);`

Записываемое в поле факта значение должно соответствовать типу данных этого поля. Если в конце построения дерева у факта остались незаполненные поля типа `required`, то факт не будет сохранен в выходной файл.


## Получение фактов из внешних грамматик (оператор from) <a name="polucheniefaktovizvneshnixgrammatikoperatorfrom"></a>

В тех случаях, когда интерпретируемый символ представляет собой отдельный объект, построенный другой грамматикой, в которой были извлечены некоторые факты, эти факты можно получить в текущей грамматике. Оператор `from` позволяет явно указать при интерпретации из какого поля другого факта нужно извлечь данные для текущей интерпретации. Поля обоих фактов должны быть одинакового типа.

Оператор from в следующем примере `Animal<kwtype="cats"> interp (Circus.Staff from Animal.Small)` означает, что в поле `Staff` факта `Circus` надо положить данные из поля `Small` факта `Animal`, которое было получено интерпретацией в грамматике заданной статьей `"cats"`.

Название факта после оператора from можно опустить: `Animal<kwtype="cats"> interp (Circus.Staff from Small)`. В этом случае интерпретация будет искать любой факт с полем `Small`.

Если имена полей обоих фактов совпадают, то оператор `from` можно не использовать. Интерпретация автоматически извлечет значение поля с таким же именем. В следующем примере в поле факта попадет значение поля `Staff` из любого факта собранного грамматикой `"cats"`, если такой факт существует: `Animal<kwtype="cats"> interp (Circus.Staff)`. Если такого факта нет, то вся цепочка, представленная нетерминалом `Animal` попадет в `Circus.Staff`.


## Интерпретация с явным значением (оператор =) <a name="interpretacijasjavnymznacheniemoperator"></a>

Процедура интерпретации позволяет также указать значение факта явно. Для этого значение факта записывается в кавычках после названия поля факта и знака равенства.

> `SportVerb interp (News.Type="спорт")`


## Конкатенация (оператор +) <a name="konkatenacijaoperator"></a>

Оператор конкатенации `+` используется в тех случаях, когда необходимо собрать в поле факта объекты из цепочек, между которыми стоят другие слова. В этом случае у цепочки расположенной правее и выше в синтаксическом дереве ставится знак плюс `+` перед именем поля факта в интерпретации.

Например, для того чтобы из цепочки <q>эксперт Института экономики по нефтедобыче</q> получить факт <q>эксперт по нефтедобыче</q> можно использовать следующие правила:

```no-highlight
CompanyAndPosition-> Position<kwtype=post> interp(Data.Position)  CompanyName; 
S -> CompanyAndPosition  PrepostionalPhrase interp(+Data.Position);
```


## Одновременная интерпретация нескольких фактов <a name="odnovremennajainterpretacijaneskolkixfaktov"></a>

Что произойдет, если в грамматика построит дерево, в котором поле одного факта будет интерпретировано несколько раз? В этом случае существенно, что интерпретация осуществляется по символам правой части правила пошагово: слева направо. Можно представить себе, что при анализе текста парсер всегда движется по дереву слева направо и снизу вверх. Таким образом, узлы, которые находятся в дереве правее и выше обрабатываются позже. Итак, ситуация, при которой в итоговом синтаксическом дереве поле одного факта будет интерпретировано несколько раз, порождает три сценария, которые могут комбинироваться между собой.


### Пример 1
Если в одно и то же поле факта попадают две цепочки, которые пересекаются, например:
    ```no-highlight
    Animal -> Adjective Elephant interp (Animal.Big);
    Creature -> Animal interp (Animal.Big);
    ```
    то новое значение интерпретации запишется поверх старого.

### Пример 2
Если цепочки не пересекаются и у этого же факта есть другое поле, которые интерпретируется в дереве один раз, то это второе поле дублируется, и на выходе порождаются два факта с разными цепочками в первом поле и одинаковыми во втором. Например, для типа факта `Person` с полями `Name`, `Position` и `Company` для цепочки

_Вагит Алекперов_ | _,_ | _Михаил Ходорковский_ | _и_ | _Евгений Швидлер_ | _,_ | _президенты_ | _НК <q>Лукойл</q>_ | _,_ | _НК ОАО <q>Юкос</q>_ | _и_ | _НК <q>Сибнефть</q>_
----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | -----
`Person.Name` |  | `Person.Name` |  | `Person.Name` |  | `Person.Position` | `Person.Company` |  | `Person.Company` |  | `Person.Company`

можно получить три факта с повторяющимся полем `Person.Position`.

Person | &nbsp; | &nbsp; 
----- | ----- | ----- 
Name | Position | Company
Вагит Алекперов | президент | Лукойл
Михаил Ходорковский | президент | Юкос
Евгений Швидлер | президент | Сибнефть


### Пример 3
Если цепочки не пересекаются и у этого же факта нет поля, которое интерпретируется в дереве один раз, то факты интерпретируются попарно в порядке парсинга: слева направо. Например, цепочка

_Евгений Швидлер_ | _и_ | _Герман Хан_ | _,_ | _президент_ | _НК <q>Сибнефть</q>_ | _и_ | _директор_ | _Тюменской нефтяной компании_
----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | -----
`Person.Name` |  | `Person.Name` |  | `Person.Position` | `Person.Company` |  | `Person.Position` | `Person.Company`

получит интерпретацию

Person | &nbsp; | &nbsp;
----- | ----- | ----- 
Name | Position | Company
Евгений Швидлер | президент | Сибнефть
Герман Хан | директор | Тюменская нефтяная компания


Данные три сценария могут комбинироваться.


## Нормализация <a name="normalizacija"></a>

При интерпретации осуществляется нормализация значений полей факта. Нормализация выделенных объектов реализует два принципа:

1. **Морфологическая нормализация**. Выбирается синтаксическая вершина цепочки и ставится в словарную форму. Если в цепочке есть слова связанные с вершиной согласованием, то соответствующие граммемы также принимают новые значения, так чтобы согласование было соблюдено. Например, если нормализации подвергается именная группа , с вершиной , то результатом нормализации будет цепочка .
1. **Нормализация через gzt-словарь**. Если при создании цепочки, которая попала в поле факта, участвовала статья словаря с заполненным полем `lemma`, то при нормализации часть цепочки описанной этой статьей заменяется значением поля `lemma` этой статьи. При этом к новой цепочке, взятой из поля `lemma`, применяются граммемы, которые применялись к исходной цепочке в процессе построения дерева. Например, если в словаре существует статья
    ```no-highlight
    TAuxDicArticle "россия_полное_название"  
    {
        key = "российская федерация"
        lemma = "россия"
    }
    ```
    а в поле факта попадает <q>цепочка _министра культуры Российской Федерации_</q>, собранная при участии статьи `"россия_полное_название"`, то результатом нормализации будет цепочка .



## Пометы интерпретации <a name="pometyinterpretacii"></a>

Дополнительные пометы позволяют влиять ход интерпретации и нормализации. Пометы стоят на последнем месте в выражении оператора `interp` и записываются после двух двоеточий `::`. Список помет перечислен в конце этого раздела в таблице.

Несколько примеров:

```no-highlight
StreetName interp (Address.Street::not_norm);
Addressee interp (Address.Street::norm="dat,sg");
```

**Помета** | **Семантика**
----- | -----
`norm` | При нормализации вершине именной группы приписываются граммемы в поле пометы `norm`.
`not_norm` | Интерпретация проходит без нормализации.
`only_from_fact` | Нормализация происходит только в том случае, если значение поля факта извлекается из другого поля факта, полученного в результате работы другой грамматики. См. [Получение фактов из внешних грамматик (оператор from)](#polucheniefaktovizvneshnixgrammatikoperatorfrom).


