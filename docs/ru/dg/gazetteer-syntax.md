# Синтаксис газеттира

## Статья словаря в общем виде <a name="article"></a>

```no-highlight
ТипСтатьи “НазваниеСтатьи”
{
    Ключ = "..."
    Поле1 = "..."
    ...
    ПолеN = "...
}
```

Описание статьи словаря состоит из типа статьи, названия статьи и содержания статьи. Содержание статьи ограничивается фигурными скобками { }. Содержание статьи – это названия полей и их значения после знака равенства =. Каждое следующее поле отделяется переносом строки или фигурными скобками.

Фигурные скобки также отделяют внутренние блоки статьи.

```no-highlight
object “Гора”
{
    key = “Говерла”
}
```


## Тип статьи <a name="article-type"></a>

Тип статьи записывается перед ее названием. Название типа статьи может состоять из букв латинского алфавита с учетом регистра, цифр и символа подчеркивания (_). Цифры в начале названия типа статьи запрещены. Существует базовый тип статьи в газеттире — `TAuxDicArticle`, остальные типы являются производными от него и должны быть заранее объявлены. Тип статьи определяет состав ее полей.

Примеры правильных названий типов статей: `TAuxDicArticle`, `funny_animal`, `object`.

Типы статей часто используются для того, чтобы объединить статьи в определенные группы, например, все названия городов в тип статьи `city`. Для этого определяют тип статьи, производный от `TAuxDicArticle` и не содержащий полей.

> `message city : TAuxDicArticle {}`

Типы статей можно использовать в ограничениях `kwtype` и `kwset`.


## Предопределенные типы статей <a name="predopredeljonnyetipystatejj"></a>

Несколько типов статей определены во встроенном в парсер файле `kwtypes_base.proto`. Эти названия нельзя переопределять, но ими можно пользоваться в словарях, создавая статьи этого типа, и в грамматиках, ссылаясь на эти типы.

**Название типа** | **Семантика**
`fio` | встроенный в парсер C++-алгоритм выделения ФИО
`fio_without_surname` | Выделенные тем же алгоритмом ФИО, но без фамилии
`date` | встроенный в парсер алгоритм выделения дат (например, <q>01.08.1012</q>, <q>1 января 2011 года</q>)
`number` | встроенный в парсер алгоритм выделения чисел (например, <q>1342 тыс.</q>, <q>1,342 миллиона</q>)



## Название статьи <a name="article-name"></a>

Название статьи записывается в кавычках. Оно состоит из букв любого алфавита с учетом регистра, цифр и символов подчеркивание (_) и косая черта (/). Цифры в начале названия статьи запрещены. Названия статей должны быть уникальными. Перед названием статьи обязательно указываться ее тип.

Примеры правильных названий статей: `Гора`, `mountain/83`, `_dağ1`.


## Комментарии <a name="kommentarii"></a>

Комментарии вводится двумя косыми чертами (как в C++).

> `// комментарий`


## Ключ <a name="key"></a>

Ключ — это основное поле статьи. В ключе указывается, как именно ищется цепочка. В одной статье может быть несколько ключей. Текст поля key записывается в кавычках. Слова разделяются пробелами. Регистр значения не имеет.

> `key = "дед мороз"`


### Варианты ключа (|) <a name="variantykljucha"></a>

Знак | (<q>или</q>) разделяет несколько вариантов ключа.

> `key = "кто-то" | "что-то"`


### Поиск по точной форме (!) <a name="poiskpotochnojjforme"></a>

Знак `!` (<q>искать по точной форме</q>) сообщает газеттиру, что искомое слово должно совпадать с точной формой слова, указанного в ключе. Знак `!` распространяется только на слово, перед которым он находится.

> `key = { "не !дай !бог" }`

Помета `morph = EXACT_FORM` аналогична знаку <q>!</q>, поставленному перед каждым словом ключа. Например:

> `key = { "не дай бог" morph = EXACT_FORM }`


### Ссылка на другую статью ($) <a name="ssylkanadrugujustatju"></a>

Статья, на которую ссылается этот ключ, должна быть описана выше. Название статьи должно быть указано полностью: не разрешается ссылаться на группу статей, объединенных одинаковым префиксом перед знаком косая черта /. Важно понимать, что когда статья передается в ключ таким образом, теряется информация о главных словах.

> `key = “дикий $название_животного”`


### Регистр (Case = UPPER) <a name="registrcaseupper"></a>

Обозначает, что значение ключа статьи должно быть в верхнем регистре. Например:

> `key = { "только в верхнем регистре" Case = UPPER }`


### Главное слово статьи (mainword) <a name="glavnoeslovostatimainword"></a>

Помета указывает, какое из слов ключа является главным словом (вершиной) статьи. Грамматическая информация от этого слова присваивается цепочке, которую описывает статья. Номера слов считаются, начиная с 1. Например:

> `key = { "дикая собака" mainword = 2 }`

Если mainword записывается снаружи ключа, то он относится ко всем ключам данной статьи. Например:

> ```no-highlight
> key = "дикая собака"
> key = "дикий кот"
> mainword = 2
> ```


### Замена цепочки (lemma) <a name="lemma"></a>

Поле `lemma` указывает значение, на которое заменяется цепочка, определенная статьей. Эта замена происходит в полученной цепочке, а также в фактах, в которых эта цепочка используется. Например:

В поле `lemma` можно указать параметры `always` и `indeclinable`:

\* если значение параметра `always = 1`, то определенная статьей цепочка заменяется на значение поля `lemma`, даже если статья не участвовала в формировании цепочки, в которую она включается. По умолчанию `always = 0`.

\* если значение `indeclinable = 1`, то при лемматизации значение поле `lemma` не меняется. По умолчанию `indeclinable = 1`


## Грамматические пометы в описании ключей <a name="grammaticheskiepometyvopisaniikljuchejj"></a>

### Помета gram <a name="pometagram"></a>

Значения этого поля — граммемы (см. список всех используемых граммем в разделе [Значения граммем](grammemes-values.md)), которые применяются к ключу. Например, gram=sg означает, что статье соответствуют только формы ключа в единственном числе. Например:

> `key = { "стол" gram=sg }`


#### Помета word <a name="pometaword"></a>

Помета word указывает, к какому из слов многословного ключа применяется помета gram. Если помета word отсутствует, то gram применяется ко всему ключу (надо проверить). Например:

> `key = { "право потребитель" gram = {"мн", word=1} gram = {"род", word=2} }`


### Согласование (помета arg) <a name="soglasovaniepometaarg"></a>

Помета описывает согласование между двумя словами в ключе. Возможны два типа согласования:

\* по роду, числу и падежу: `agr=gnc_agr` или `agr=GENDER+NUMBER+CASE`

\* по падежу: `agr=CASE`

> ```no-highlight
> key = { "автономный область" | "автономный округ" agr=gnc_agr }
> key = { "главный редактор" agr=GENDER+NUMBER+CASE }
> key = { "вооруженный сила" gram="мн" agr=CASE }
> ```


## Специальные типы ключей <a name="specialnyetipykljuchejj"></a>

Есть два специальных типа ключей:

\* `type = CUSTOM` для подключения к словарю грамматик и встроенных в парсер алгоритмов

\* `type = FILE` для файлов со списками слов и словосочетаний

> \* `key = { "alg:fio" type=CUSTOM }` — ссылается на C++ алгоритм выделения ФИО
> 
> \* `key = { "tomita:geo/city.cxx" type=CUSTOM}` — ссылается на грамматику. Можно указывать относительный или полный путь.
> 
> \* `key = { "animals.txt" type=FILE }` — ссылается на файл со списком слов.

