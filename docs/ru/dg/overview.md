# Принцип работы

## Алгоритм работы парсера на одном предложении и одной грамматике <a name="algoritm"></a>

1. Ищутся вхождения всех ключей из газеттира. Если ключ состоит из нескольких слов (например, «Нижний Новгород»), то создается новое искусственное слово, которое мы называем «мультиворд».
1. Из всех найденных ключей газеттира отбираются те, которые упоминаются в грамматике (см. [Помета kwtype](labels-limits.md)).
1. Среди отобранных ключей могут встречаться и мультиворды, пересекающиеся друг с другом или включающие в себя одиночные ключевые слова. Парсер пытается покрыть предложение непересекающимися ключевыми словами так, чтобы как можно большие куски предложения были охвачены ими.
1. Линейная цепочка слов и мультивордов подается на вход GLR-парсеру. Терминалы грамматики отображаются на входные слова и мультиворды.
1. На последовательности множеств терминалов GLR-парсер строит все возможные варианты. Из всех построенных вариантов также отбираются те, которые как можно шире покрывают предложение.
1. Затем парсер запускает процедуру [интерпретации](interpretation.md) на построенном синтаксическом дереве. Он отбирает специально помеченные подузлы, а слова, которые им соответствуют, записываются в порождаемые грамматикой поля фактов.



## Исходные файлы простого проекта <a name="source-files"></a>

Для запуска Томита-парсера необходимо создать файлы, перечисленные в следующей таблице.

**Содержание** | **Формат** | **Примечания**
----- | ----- | -----
**config.proto** — конфигурационный файл парсера. Сообщает парсеру, где искать все остальные файлы, как их интерпретировать и что делать. | Protobuf | нужен всегда
**dic.gzt** — корневой словарь. Содержит перечень всех используемых в проекте словарей и грамматик. | Protobuf / Gazetteer | нужен всегда
**mygram.cxx** — грамматика | Язык описания грамматик | Нужен, если в проекте используются грамматики. Таких файлов может быть несколько.
**facttypes.proto** — описание типов фактов | Protobuf | Нужен, если в проекте порождаются факты. Парсер запустится без него, но фактов не будет.
**kwtypes.proto** — описания типов ключевых слов | Protobuf | Нужен, если в проекте создаются новые типы ключевых слов.


Таким образом, минимальный набор файлов для запуска парсера включает конфигурационный файл и корневой словарь. При этом не будут использоваться грамматики и пользовательские типы ключевых слов, а также не будут порождаться факты. Типовой сценарий использования парсера подразумевает наличие всех пяти типов файлов.

### Каскады

В качестве ключевых слов могут быть использованы результаты работы других грамматик. Тогда на шаге 2 предыдущего алгоритма парсер смотрит, какие ключевые слова задаются не списком слов, а конкретными грамматиками (см. [специальные типы ключей](gazetteer-syntax.md)). Если такие ключи есть, то он рекурсивно запускает тот же алгоритм на всех грамматиках, упомянутых в статьях для этих ключевых слов. Выделенные этими грамматиками цепочки становятся мультивордами и смешиваются с остальными ключевыми словами. Таким образом, можно строить целые деревья парсеров, подавая результаты работы одного в качестве входных символов другого.

### Адресация

Главным элементом для парсера является [статья из газеттира](gazetteer-syntax.md). Статью можно представлять в виде функции на предложении, результатом работы которой всегда является выделенная подцепочка. [Имя статьи](gazetteer-syntax.md) тогда является именем этой функции, а [тип статьи](gazetteer-syntax.md) — множеством функций, применяемых в случайном порядке. Внутри этой статьи-функции явно указано, каким способом выделить нужную цепочку: грамматикой или поиском указанных слов и словосочетаний. Вся связь между грамматиками происходит через статьи газеттира, в которых в ключе [вместо слов указана грамматика](link.md). В [параметрах к парсеру](run-parser.md) указываются также имена газеттирных статей, т.е. вызываются функции, выделяющие подцепочки.

### Веса <a name="weights"></a>

Парсер может порождать много вариантов разбора одной и той же цепочки, которые отличаются только деревом разбора. Различные деревья могут порождать разные варианты заполнения полей фактов. Для этой цели правилу можно приписывать вес (см. описание пометы `weight` в разделе [операции над правилами](rules.md#weight)). По умолчанию вес у всех правил равен 1. Но его можно искусственно уменьшить, чтобы парсер выбрал вариант с бóльшим весом, если такой построился.

