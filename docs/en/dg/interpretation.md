# Interpretation and normalization

Interpretation is a way to save text analysis results in a convenient tabular format for further processing, such as for storing in a database. Interpretation is the last stage of text processing in the Tomita parser. The interpretation process consists of populating fact fields with the subchains from an extracted grammatical chain.

A fact is a set of values for attribute fields that are connected by semantic relationships. For example, the fact "Meeting" may have the fields "Place", "Time", and "Theme".


## Formal definition <a name="defin"></a>

Interpretation is a procedure that allows the syntactic tree structure to be displayed as a linear set of facts. Each fact can be visualized as a table consisting of one line and one or more columns; each cell in this table contains an object. The goal of interpretation is to match a set of nonterminals constructed for a grammar to a set of objects extracted for a particular type of fact; in other words, to distribute subchains of words across pre-set fields in a table.


## Fact type descriptions <a name="facts"></a>

Every fact generated by a grammar must be described. Facts are described in a gzt-type dictionary. The name of the fact is set after the word `message`, and the fact's type is entered after its name. The base type for all facts is `NFactType.TFact`. Fact fields are listed in curly brackets `{ }`.

> ```no-highlight
> message SomeFactName : NFactType.TFact
> {
> ...
> }
> ```

Fact types can have inheritance. All the fields that occur in a fact's base type will also occur in a derivative type. In order for derivative types to be inherited from a base fact type, a range of field numbers must be specified to reserve for use in derivative types: `extensions 2 to 10`.

> ```no-highlight
> message BasicFact : NFactType.TFact
> {
>   required string field1 = 1;
>   extensions 2 to 10;
> }
> message DerivedFact : BasicFact
> {
>   required string field2 = 2;
>   required string field3 = 3;
> }
> ```

The Protobuff type description language is described in the documentation [Protocol Buffers/Language Guide](https://developers.google.com/protocol-buffers/docs/proto#extensions).


## Fact fields <a name="poljafaktov"></a>

All fact fields have the following characteristics: field name, field type, and mandatory field completion. All three characteristics must be explicitly specified when describing a fact type.

Field types belong to one of the four types listed in the table.

**Field type** | **Description** | **Sample values**
----- | ----- | -----
`string` | String. This is a universal field that may contain any string values. | painted turtle<br/><br/>11.5<br/><br/>news.yandex.ru
`bool` | Boolean data type that allows one of two values: `true` or `false`. | `true`<br/><br/>`false`
`NFactType.TFio` | Type for storing full names: surnames, first names and patronymics, or initials. | Murray Bill<br/><br/>Kalugina L.P.
`NFactType.TDate` | Type for storing dates and times or a time interval, extracted using entries with one of the two special types: `date` or `date_chain`. | 1997-11-23 00:00:00<br/><br/>2011-06-17 19:30:00<br/><br/>2012-02-20 00:00:00 - 2012-02-22 00:00:00


The field completion requirement is set using the service word `required` or `optional` followed by the name of the field type (see the table above), then its name and, after the equal sign `=`, the number of the fact field and a semicolon. The words `required` and `optional` indicate whether the fact field is mandatory or optional. If one or more of the mandatory fields remains empty during the process of constructing the tree, the fact is not retrieved.

> `optional string CountryName = 1;`

Field numbers must be unique for each fact. This is why it is important to remember that if a fact inherited its type from another fact, it also inherited its fields and their numbers.


## Default field values <a name="znachenijapolejjpoumolchaniju"></a>

When describing a fact field, a default value can be assigned to it. In this case, if at least one other field is filled in for this fact, this field will already have the default value set. The default value will change if this field is filled in with a different chain during interpretation.

The default value is set in square brackets `[ ]` in the `default` parameter, after the field declaration, as shown in the following example:

> `optional string Animal = 1 [ default = "unknown animal" ];`


## Capitalization of fact fields <a name="kapitalizacijapolejjfaktov"></a>

When describing facts, you can set the desired capitalization for their values in output. Tags that affect capitalization are entered in square brackets `[ ]` after field descriptions. A comma is used to separate tags. These tags and their values are listed below:

Field type | Description
----- | -----
`[(NFactType.normcase) = TITLE_CASE]` | Capitalize the first letter of the first word
`[(NFactType.normcase) = CAMEL_CASE]` | Capitalize the first letter of each word



## Saving lemmas <a name="soxranenielemm"></a>

The `[(NFactType.info) = true]` tag tells the parser to save word lemmas in the output file and mark the head words.


## Interpreting facts in grammars <a name="interpretacijafaktovvgrammatikax"></a>

The `interp` operator is used in Tomita for entering chains in the fact interpretation field. A chain identified by a symbol followed by `interp` is entered in the fact field that is designated in parentheses after `interp`.

> `Animal -> Cat interp (Animal.Small);`

In this example, the chain linked by the `Cat` nonterminal is entered in the `Small` field of the `Animal` fact. A single symbol can be interpreted to multiple fields, and even to multiple fields of different facts. To do this, fields are listed with semicolons `;` between them.

> `Animal -> Cat interp (Animal.Small; Object.Animate);`

The value entered in the fact field must match the data type for this field. If the fact still has empty `required` fields when the tree has been constructed, the fact will not be saved in the output file.


## Getting facts from external grammars (the "from" operator) <a name="polucheniefaktovizvneshnixgrammatikoperatorfrom"></a>

In cases when the interpreted symbol is a separate object built by a different grammar, and that grammar had certain facts extracted, you can get these facts in the current grammar. The `from` operator lets you explicitly set a field in a different fact to use for extracting data for the current interpretation. Both fact fields must have the same type.

The "from" operator in the following example `Animal<kwtype="cats"> interp (Circus.Staff from Animal.Small)` means that in the `Staff` field for the `Circus` fact, data must be added from the `Small` field for the `Animal` fact, which was obtained by interpretation in the grammar for the specified `"cats"` entry.

The fact name can be omitted after the "from" operator: `Animal<kwtype="cats"> interp (Circus.Staff from Small)`. In this case, interpretation looks for any fact with the `Small` field.

If the field names of both facts are the same, the `from` operator does not need to be used. Interpretation automatically extracts the value of the field with the same name. In the following example, the fact field will get the value of the `Staff` field from any fact assembled using the `"cats"` grammar, if such a fact exists: `Animal<kwtype="cats"> interp (Circus.Staff)`. If there is no such fact, the entire chain represented by the `Animal` nonterminal goes in `Circus.Staff`.


## Interpretation with explicit values (the = operator) <a name="interpretacijasjavnymznacheniemoperator"></a>

The interpretation process also lets you specify a fact value explicitly. To do this, the fact value is entered in quotation marks after the name of the fact field and the equal sign.

> `SportVerb interp (News.Type="sports")`


## Concatenation (the + operator) <a name="konkatenacijaoperator"></a>

The concatenation operator `+` is used in cases when the fact field must collect objects from chains that have other words between them. In this case, the chain located right-most and highest in the syntactic tree is given the plus sign `+` before the name of the fact field in interpretation.

For example, to use the chain <q>expert of the Institute of Economics on oil production</q> to get the fact <q>expert on oil production</q>, the following rules can be used:

```no-highlight
CompanyAndPosition-> Position<kwtype=post> interp(Data.Position)  CompanyName; 
S -> CompanyAndPosition  PrepostionalPhrase interp(+Data.Position);
```


## Simultaneous interpretation of multiple facts <a name="odnovremennajainterpretacijaneskolkixfaktov"></a>

What will happen if a tree is formed in a grammar, and in this tree a field for a single fact is interpreted multiple times? In this case, it is essential that the symbols on the right side of the rule are interpreted in order from left to right. We can think of the parser as analyzing text by always moving along the tree from left to right and bottom to top. So nodes that are located right-most and highest in the tree are processed later. This means that the situation in which the field of a single fact in the resulting syntactic tree is interpreted multiple times actually creates three scenarios that can be combined with each other.

1. If two overlapping chains end up in the same fact field, for example:
    ```no-highlight
    Animal -> Adjective Elephant interp (Animal.Big);
    Creature -> Animal interp (Animal.Big);
    ```
    then the new interpreted value is written over the old one.
1. If the chains do not overlap and this same fact has a different field that is interpreted in the tree one time, this second field is copied, and the output generates two facts with different chains in the first field and identical chains in the second field. For example, for the `Person` fact type with the `Name`, `Position`, and `Company` fields for the chain
    _Vagit Alekperov_ | _,_ | _Mikhail Hodorkhovskiy_ | _and_ | _Evgeniy Shvidler_ | _,_ | _presidents_ | _Oil Co <q>Lukoil</q>_ | _,_ | _Oil Co OJSC <q>Yukos</q>_ | _and_ | _Oil Co <q>Sibneft</q>_
    `Person.Name` |  | `Person.Name` |  | `Person.Name` |  | `Person.Position` | `Person.Company` |  | `Person.Company` |  | `Person.Company`
    we can get three facts with the `Person.Position` field repeated.
    Person
    -----
    Vagit Alekperov | president | Lukoil
    Mikhail Hodorkhovskiy | president | Yukos
    Evgeniy Shvidler | president | Sibneft
1. If the chains do not overlap and the same fact does not have any fields that are interpreted one time in the tree, the facts are interpreted in pairs in the parsing order, from left to right. For example, the chain
    _Evgeniy Shvidler_ | _and_ | _German Han_ | _,_ | _president_ | _Oil Co <q>Sibneft</q>_ | _and_ | _director_ | _Tumenskaya Oil Company_
    `Person.Name` |  | `Person.Name` |  | `Person.Position` | `Person.Company` |  | `Person.Position` | `Person.Company`
    gets interpreted as
    Person
    -----
    Evgeniy Shvidler | president | Sibneft
    German Han | director | Tumenskaya Oil Company


These three scenarios may be combined.


## Normalization <a name="normalizacija"></a>

During interpretation, fact field values are normalized. Normalization of extracted objects involves two principles:

1. **Morphologic normalization**. The syntactic head of the chain is selected and lemmatized. If the chain contains words that are connected to the head by agreement, the corresponding grammemes also take new values, so that agreement is maintained. For example, if the nominal group being normalized is  ("new minister"; singular masculine instrumental adjective, singular masculine instrumental noun) with the noun  as the head, the resulting lemmatized chain is  (singular masculine nominative adjective, singular masculine nominative noun).
1. **Normalization using gzt dictionary**. If a dictionary entry with the `lemma` field filled in was used during the creation of a chain that ended up in a fact field, during normalization, part of the chain described by this entry is replaced with the value of the `lemma` field for this entry. The new chain taken from the `lemma` field has the grammemes applied to it that were applied to the original chain when constructing the tree. For example, if the dictionary has the entry
    ```no-highlight
    TAuxDicArticle "russia_full_name"  
    {
        key = "russian federation"
        lemma = "russia"
    }
    ```
    and the fact field gets the chain , assembled using the entry `"russia_full_name"`, the result of normalization is the chain .



## Interpretation tags <a name="pometyinterpretacii"></a>

There are additional tags for controlling the interpretation and normalization processes. These tags go in the last place in the expression for the `interp` operator and are entered after double colons `::`. The tags are listed in the table at the end of this section.

Examples:

```no-highlight
StreetName interp (Address.Street::not_norm);
Addressee interp (Address.Street::norm="dat,sg");
```

**Tag** | **Semantics**
----- | -----
`norm` | When normalizing the head of a nominal group, grammemes are appended in the `norm` tag field.
`not_norm` | Interpretation proceeds without normalization.
`only_from_fact` | Normalization occurs only if the value of the fact field is extracted from a different fact field that was obtained as the result of a different grammar. See [Getting facts from external grammars (the "from" operator)](#polucheniefaktovizvneshnixgrammatikoperatorfrom).
`un_status` | The `un_status` tag is only applied to the field with the `Status` name. The chain is not interpreted if one of the following conditions is met: <br/>1. the first word in the chain is a possessive pronoun<br/>1. the main word in the chain is in the list of words with the `antistatus` type<br/>1. all the words in the chain are either numerals, or words with the `light_status` type<br/>1. the number of open quotation marks in the chain is not equal to the number of closed quotation marks<br/><br/>This tag is only relevant for Press.Portraits and News. Not described in external documentation.


